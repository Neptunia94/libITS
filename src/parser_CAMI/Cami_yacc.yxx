/****************************************************************************/
/*								            */
/* This file is part of the PNDDD, Petri Net Data Decision Diagram  package.*/
/*     						                            */
/*     Copyright (C) 2004 Denis Poitrenaud and Yann Thierry-Mieg            */
/*     						                            */
/*     This program is free software; you can redistribute it and/or modify */
/*     it under the terms of the GNU General Public License as published by */
/*     the Free Software Foundation; either version 2 of the License, or    */
/*     (at your option) any later version.                                  */
/*     This program is distributed in the hope that it will be useful,      */
/*     but WITHOUT ANY WARRANTY; without even the implied warranty of       */
/*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
/*     GNU General Public License for more details.                         */
/*     						                            */
/*     You should have received a copy of the GNU General Public License    */
/*     along with this program; if not, write to the Free Software          */
/*Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/*     						                            */
/****************************************************************************/
 


/****************************************************************************************
*  created by   : Mr Denis POITRENAUD and Cherif Reda HASSAINE
*  created date : 19/05/2003
*  subject      : parser of CAMI syntaxe
*  version      : 0.1
****************************************************************************************/

%{
/*..................................... include C......................................*/
#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <stdlib.h>
using namespace std;


#include "Cami.hpp"
using namespace cami;


 string value;
 static CAMI *R;
 static vector<int> Net;
 static vector<int> Immediate;
 map<int,int> RESET;
/*.................................variable environment................................. */

 extern int Camilex();
 extern int Camilineno;
 extern FILE *Camiin;              
 extern ostream& yyerror(const char* s){
	  if (s) {
        string value=string(" (incorrect Modèl) ");
        string err=string(s);
        if(value != err)
          cout<<"error line "<<Camilineno<<" : ";
        cout<<s;
        err.erase();
	  }
	  else {
		    cout<<"parsing error:"<<endl;
	  }
	  fclose(Camiin);
    Net.clear();
    Immediate.clear();
    RESET.clear();
    value.erase();
    return cout;
  }
%}
/*.................................Bison Declarations ................................ */

%union {
   int  j;
  char *s;
  struct cami::LossCty LC;  //pour les attributs Loss et capacity
}

/*......................................token ........................................*/

%token <s> IDENT DENT 
%token <j> ENTIER
%token ESPACE  DB  FB  CA  CT  CN  CM CP LOSS COMMENTAIRE PO PT EFT LFT VISIBILITY LABEL
%token NET PLACE QUEUE TRANSITION IMMEDIATE  NAME DECLARATION AUTHORS CAMIVERSION TITLE PROJECT DATE CODE DOMAINE
%token COMPONENT GUARD PRIORITY DELAY ACTION WEIGHT CAPACITY VALUATION MARKING ARC INHIBITOR
/*......................................type..........................................*/
%type <LC> loss_capacity
%type <s>  ensemblexpression
%left ':' ',' '.'
%left '('  ')'

%name-prefix="Cami"

/*.................................begin of parse ....................................*/
%start begin
%%
begin : ESPACE  debut
      |
       debut
;
debut:  DB  creation  {for(map<int,int>::const_iterator it=RESET.begin(); it !=RESET.end(); it++){
                                 if(!R->setValuationRESET(it->first)){
				                              yyerror("input transition ARC RESET at ")<<it->second<<"  was Output Arc"<<endl;return 1;
			                            }
                      }
        }FB
		  |
      erreur {yyerror(" (incorrect Modèl) ")<<endl;exit(1);}
      |
      debut ESPACE
      |
      '\n'
;
creation :  commande |
            creation commande|
	          creation COMMENTAIRE IDENT |
	          '\n'
;
commande :
	PO '(' ENTIER ',' ENTIER ',' ENTIER ')'
    	{  /* IGNORE GRAPHICAL POSITION INFO */ } 
	|	PT '(' ENTIER ',' ENTIER ':' tagident ',' ENTIER ',' ENTIER ')'
	{  /* IGNORE GRAPHICAL POSITION INFO */ }
        |    CN   '('  NET   ','  ENTIER  ')'
	{
	  Net.push_back($5);
	}
        |
	CN   '('  PLACE   ','  ENTIER  ')'
	{		
	  if( ! R->addPlace( $5) ) {
	    yyerror("create the place")<<endl;return 1;
	  }
	}
        |
	CN   '('  QUEUE   ','  ENTIER  ')'
	{		
	  if( ! R->addQueue( $5) ) {
	    yyerror("create the queue")<<endl;return 1;
	  }
	}
        |
	CN   '('  TRANSITION   ','  ENTIER  ')'
	{
	  if(! R->addTrans( $5 )){
	    yyerror("create the transition")<<endl;return 1;
	  }
	}
	|
	CN   '(' IMMEDIATE   ','  ENTIER  ')'
	{
	  Immediate.push_back($5);
	}
	|
	CT   '('  NAME    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	 {
	   value= string($9);
	   if($7!=(int)value.size() ||  value.find(" ")!=string::npos) {
	     yyerror("Incorrect length of the identifier transition or place")<<endl;return 1;
	   }
	   if( !R->nameNode($5, value) ){
	     if( binary_search(Immediate.begin(),Immediate.end(),$5) ) {
	       yyerror("because Immediate transition ")<<endl;return 1;
	     }
	     yyerror("Create the Transition or Place")<<endl;return 1;
	   }
	 }
        |
	CT   '('   DECLARATION    ','  ENTIER  ','  ENTIER   ':' IDENT ')'
	{
	}
        |
	CT   '(' DECLARATION    ','  ENTIER  ','  ENTIER   ':' ensemblexpression ')'
	{
	}
        |
	CT   '('  AUTHORS    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
        |
	CT   '('  CAMIVERSION    ','  ENTIER  ','  ENTIER   ':'  ENTIER '.'ENTIER  ')'
	{
	}
	|
	CT   '('   TITLE    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	  value= string($9);
  
	  if($7!=(int)value.size()) {
	    yyerror("Incorrect length of the Identifier attribut title")<<endl;return 1;
	  }
	  if(!(binary_search(Net.begin(),Net.end(),$5) )){
	    yyerror("Net dosn't Existe")<<endl;return 1;
	  }

	}
        |
	CT   '('   PROJECT    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
        |
	CT   '(' DATE    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}

        |
	CT   '('  CODE    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
        |
	CT   '('   DOMAINE    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	  value= string($9);
	  if($7!=(int)value.size()) {
	    yyerror("Incorrect length of the Identifier attribut domain")<<endl;return 1;
	  }
	  if(! R->belongs_PLACE($5) ) {   /*&&  !R->get_place($7).isQueue()*/
	    yyerror("Create the Place")<<endl;return 1;
	  }
	}
        |
	CT   '('  DOMAINE    ','  ENTIER  ','  ENTIER   ':'  loss_capacity ')'
	{
	  if( R->belongs_PLACE($5) ){
	    if(R->get_place($5).isQueue()) {
	      if($9.loss) {
		if(!R->addPlace( $5 ,R->get_place($5).name,-2,$9.capacity) ){
		  yyerror("Create the Loss Queue")<<endl;return 1;
		}
	      } else {
		if(!R->addPlace( $5 ,R->get_place($5).name,R->get_place($5).marking,$9.capacity) ){
		  yyerror("Create the Queue")<<endl;return 1;
		}
	      }
	    } else {
	      if(! $9.loss) {
		if(!R->addPlace( $5 ,R->get_place($5).name, R->get_place($5).marking,$9.capacity) ){
		  yyerror("Create the Place")<<endl;return 1;
		}
	      } else {
		yyerror("'Loss' is not Place's attribut ")<<endl;return 1;
	      }
	    }
	  } else {
	    yyerror("Create the Place")<<endl;return 1;
	  }
	}
	|
	CT   '('  COMPONENT   ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
        |
	CT   '(' GUARD    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
        |
	CT   '('   PRIORITY    ','  ENTIER  ','  ENTIER   ':'  ENTIER  ')'
	{
	}
        |
	CT   '('  DELAY    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
	|
	CT   '(' ACTION    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
        |
	CT   '(' WEIGHT    ','  ENTIER  ','  ENTIER   ':'  IDENT  ')'
	{
	}
	|
	CT   '(' CAPACITY     ','  ENTIER  ','  ENTIER   ':'  ENTIER    ')'
	{
	  if(! R->addPlace( $5 ,R->get_place($5).name,R->get_place($5).marking,$9 ) ){
	    yyerror(" create place's capacity ")<<endl;return 1;
	  }
	}
	|
	CT   '('   VALUATION     ','  ENTIER  ','  ENTIER   ':'  ENTIER    ')'
	{
	  if(! ( R->belongs_Arc($5) && R->setValuation($5 ,$9) ) ){
	    yyerror("arc's valuation ")<<endl;return 1;
	  }
	}
        |
	CT   '('  VALUATION     ','  ENTIER  ','  ENTIER   ':'  IDENT    ')'
	{
	  value= string($9);
	  if($7!=(int)value.size()) {
	    yyerror("Incorrect length of the Identifier attribut valuation")<<endl;return 1;
	  }
	  if(! ( R->belongs_Arc($5) && R->setValuation($5 ,value) ) ){
	    yyerror("arc's valuation ")<<endl;return 1;
	  }
	}
        |
	CT   '('  VALUATION     ','  ENTIER  ','  ENTIER   ':'  '#'    ')'
	{
	  if( $7!=1) {
	    yyerror("Incorrect length of the word 'valuation'")<<endl;return 1;
	  }
	  RESET[$5]=Camilineno;
	}
	|
	CT   '('   MARKING     ','  ENTIER  ','  ENTIER   ':'  ENTIER    ')'
	{
	  if(!( ($9 >= 0) && R->addPlace( $5,R->get_place($5).name,$9,R->get_place($5).capacity)
		&& !R->get_place($5).isQueue() ) ){
	    yyerror("place's marking")<<endl;return 1;
	  }
	}
	|
	CA   '('   ARC   ','  ENTIER  ','  ENTIER   ','  ENTIER   ')'
	{
	  if (!R->belongs_Arc($5)) {
	    if( R->belongs_PLACE($7) && R->belongs_TRANS($9)) {
	      R->addPre($5,$7,$9);
	    } else {
	      if (R->belongs_PLACE($9) && R->belongs_TRANS($7))
		R->addPost($5,$9,$7);
	      else 
		yyerror("create the Arc")<<endl;return 1;
	    }
	  } else {
	    yyerror("Arc exist")<<endl;return 1;
	  }
	}
        |
	CA   '('  INHIBITOR   ','  ENTIER  ','  ENTIER   ','  ENTIER   ')'
	{		   
	  if( ! (!R->belongs_Arc($5)&& R->addInhibitor($5,$7,$9))){
	    yyerror("create the Inhibitor Arc")<<endl;return 1;
	  }
	}
        |
   	CM  '('  NAME  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{
	  value =string($13);
	  if($11!=(int)value.size() ||  value.find(" ")!=string::npos) {
	    yyerror("Incorrect length of the Identifier attribut name")<<endl;return 1;
	  }
	  if( !R->belongs_PLACE($5)&& !R->belongs_TRANS($5)) {
	    yyerror("place or transition doesn't existe")<<endl;return 1;   //
	  }
	  if( R->belongs_PLACE($5))
	    R->get_place($5).name +=$13;
	  else
	    R->get_transition($5).name +=$13;
	}
        |
	CM  '('   DECLARATION  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':' IDENT ')'
	{ 
	}
        |
	CM  '('   AUTHORS  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{  
	}
        |
	CM  '('   CAMIVERSION  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  ENTIER '.'ENTIER  ')'
	{
	}
	|
	CM  '('   TITLE  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
        {  
	}
        |
	CM  '(' PROJECT  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{
	}
	|
	CM  '(' DATE  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{  
	}
	|
	CM  '(' CODE  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{  
	}
        |
	CM  '('   DOMAINE  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{
	}
        |
	CM  '('GUARD  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	{  
	}
        |
	  CM  '(' COMPONENT  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	  {  
	  }
		|
	  CM  '('  DELAY  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	  {  
	  }
		|
	  CM  '(' ACTION  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	  {  
	  }
		|
	  CM  '(' WEIGHT  ','  ENTIER  ',' ENTIER  ',' ENTIER  ','  ENTIER ':'  IDENT  ')'
	  {  
	  }
		|
		ESPACE
;
ensemblexpression : ensemblexpression DENT
                  |
                   DENT
;
erreur : error
;

tagident : NAME | MARKING | IDENT ;

loss_capacity :   CP '(' ENTIER ')'
                  {
                    $$.capacity=$3;
                    $$.loss=0;
                  }
               |
                 LOSS
                 {
                    $$.capacity=0;
                    $$.loss=1;
                  }
               |
                  CP '(' ENTIER ')'  ',' LOSS
                  {
                    $$.capacity=$3;
                    $$.loss=1;
                  }
               |
                   LOSS ',' CP '(' ENTIER ')'
                  {
                    $$.capacity=$5;
                    $$.loss=1;
                  }
;
%%
/*......................................................................................... */
bool CamiMonteur::create(const char *f){
  int i;
  if((Camiin=fopen(f,"r"))==NULL)
    return false;                                                
  R=(CAMI *)this;
  i=(int) yyparse();
  fclose(Camiin);
  Net.clear();
  Immediate.clear();
  RESET.clear();
  value.erase();
  return (i==0); // return i
}





